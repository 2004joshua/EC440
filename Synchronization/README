The user's project involves implementing a user-level preemptive thread library in C, which allows for the management of threads at a user level, offering more control and flexibility in handling concurrent tasks. Unlike kernel-level threads managed by the operating system, user-level threads are managed entirely by the application, making them lightweight and efficient for certain applications. The project includes functions such as create, exit, join, and schedule, which respectively handle the creation of threads, termination of threads, waiting for threads to finish, and scheduling of threads using a round-robin algorithm. These functions provide a framework for managing threads in a concurrent application, enabling efficient multitasking and resource sharing.

During the development of the user-level preemptive thread library, the user relied on several external resources. They used IBM Documentation for insights into thread management and scheduling algorithms, Stack Overflow for resolving specific coding issues and best practices, and a YouTube channel called Code Vault for tutorials and explanations on advanced C programming concepts. These resources were instrumental in overcoming various challenges and ensuring the successful implementation of the thread library.

Project Description
In this project, I extended the functionality of our custom threading library developed in previous assignments by implementing key synchronization mechanisms. The primary goal was to enable threads to share data safely and coordinate their execution points effectively. Key features added include mutexes and barriers, which are crucial for ensuring mutual exclusion and synchronizing thread progress at predetermined points. These additions facilitate the development of more complex, multithreaded applications by providing the necessary tools to manage concurrent access to shared resources and coordinate the execution flow of threads.

The implementation involved creating several new functions: pthread_mutex_init, pthread_mutex_destroy, pthread_mutex_lock, pthread_mutex_unlock, pthread_barrier_init, pthread_barrier_destroy, and pthread_barrier_wait. Each function was carefully developed to handle specific aspects of thread synchronization, such as initializing and destroying mutexes and barriers, locking and unlocking mutexes, and managing barrier synchronization points. Special attention was given to ensuring that the locking mechanisms prevent the scheduler from executing at inopportune times, thus avoiding race conditions and deadlocks. The project posed several challenges, particularly in managing the internal state of mutexes and barriers and ensuring that threads blocked on these synchronization primitives are handled correctly by the scheduler.

IBM Documentation - pthread_create | https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-pthread-create-create-thread
Stack Overflow | https://stackoverflow.com/
Code Vault YouTube Channel | https://www.youtube.com/@CodeVault
GeeksforGeeks | https://www.geeksforgeeks.org/types-of-locks-in-concurrency-control/
